const { productButtons } = require('../../Components/Buttons');
const { Status } = require('../../Components/Status');
const {
  getProductsByStatus,
  updateProduct,
} = require('../../Storages/ProductStorage');
const { changeProductText } = require('../../utils/changeProductText');
const { sendMessageToUser } = require('../../utils/sendMessageToUser');

module.exports = (app, bot) => {
  try {
    const adminId = process.env.ADMIN_ID;

    bot.on('text', async (msg) => {
      try {
        const { from } = msg;
        if (+from.id === +adminId) {
          // if (msg.text.toString().includes(Status.Reject)) {
          //   const status = Status.Reject;
          //   // const { text } = msg;
          //   const result = await updateProductStatus({
          //     id: '',
          //     status,
          //   });
          //   bot.sendMessage(
          //     result.userTGId,
          //     `–ê–¥–º–∏–Ω –æ—Ç–º–µ–Ω–∏–ª –≤–∞—à—É –ø–æ—Å—ã–ª–∫—É: \n${result.trackNumber} –ü–æ –ø—Ä–∏—á–∏–Ω–µ: ${''}`,
          //     {
          //       reply_markup: {},
          //     },
          //   );
          //   bot.sendMessage(adminId, '–°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', {
          //     reply_markup: {},
          //   });
          // }

          if (msg.text == 'üõ†–ó–∞–∫–∞–∑—ã –≤ —Ä–∞–±–æ—Ç–µ') {
            const status = Status.OnReview;
            const result = await getProductsByStatus({ status });
            if (result.length <= 0) {
              bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
                reply_markup: {},
              });
            }
            result.forEach((product) => {
              const productText = changeProductText(product);

              // Create a unique callback data for each product
              const callbackData = `${product._id}`;

              bot.sendMessage(adminId, productText, {
                reply_markup: {
                  inline_keyboard: [
                    ...productButtons(product._id, Status),
                    product.status === Status.OnReview && [
                      {
                        text: '–í –∞—Ä—Ö–∏–≤',
                        callback_data: `${callbackData}:${Status.Archive}`,
                      },
                    ],
                  ],
                },
              });
            });
          }

          // if (msg.text == '–ó–∞–∫–∞–∑—ã –≤ —Ä–∞–±–æ—Ç–µ') {
          //   const status = Status.OnReview;
          //   const result = await getProductsGeneralByStatus({ status });
          //   if (result.length <= 0) {
          //     bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
          //       reply_markup: {},
          //     });
          //   }
          //   result.forEach((product) => {
          //     const productText = `${product.productText}\n${product.updatedAt}`;

          //     bot.sendMessage(adminId, productText, {
          //       reply_markup: {},
          //     });
          //   });
          // }

          if (msg.text == 'üìå–ó–∞–∫–∞–∑—ã –Ω–∞ –¥–æ—Ä–∞–±–æ—Ç–∫—É') {
            const status = Status.ToEdit;
            const result = await getProductsByStatus({ status });
            if (result.length <= 0) {
              bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
                reply_markup: {},
              });
            }
            result.forEach((product) => {
              const productText = changeProductText(product);

              bot.sendMessage(adminId, productText, {
                reply_markup: {},
              });
            });
          }

          if (msg.text == '‚ùå–û—Ç–º–µ–Ω–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã') {
            const status = Status.Reject;
            const result = await getProductsByStatus({ status });
            if (result.length <= 0) {
              bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
                reply_markup: {},
              });
            }
            result.forEach((product) => {
              const productText = changeProductText(product);

              bot.sendMessage(adminId, productText, {
                reply_markup: {},
              });
            });
          }
          if (msg.text == '‚úÖ–ù–æ–≤–∏–µ –∑–∞–∫–∞–∑–∏') {
            const status = Status.New;
            const result = await getProductsByStatus({ status });
            if (result.length <= 0) {
              bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
                reply_markup: {},
              });
            }
            result.forEach((product) => {
              const productText = changeProductText(product);

              // Create a unique callback data for each product

              bot.sendMessage(adminId, productText, {
                reply_markup: {
                  inline_keyboard: [...productButtons(product._id, Status)],
                },
              });
            });
          }
          if (msg.text == 'üßôüèº‚Äç‚ôÇÔ∏è–ê—Ä—Ö–∏–≤') {
            const status = Status.Archive;
            const result = await getProductsByStatus({ status });
            if (result.length <= 0) {
              bot.sendMessage(adminId, '–ü—É—Å—Ç–æ', {
                reply_markup: {},
              });
            }
            result.forEach((product) => {
              const productText = changeProductText(product);

              bot.sendMessage(adminId, productText, {
                reply_markup: {},
              });
            });
          }
        }
      } catch (err) {
        console.log('err admin controller');
      }
    });
    // Listen for callback queries
    bot.on('callback_query', async (callbackQuery) => {
      try {
        const { data } = callbackQuery;
        const [productId, action] = data.split(':');
        console.log(action);
        const changeProductStatus = async ({ id, status, message }) => {
          const result = await updateProduct({ status, id });
          if (status !== Status.Archive) {
            const sendMessage = await sendMessageToUser({
              bot,
              userId: result.userTGId,
              message: `${message} \n${result.trackNumber}`,
            });

            if (!sendMessage) {
              await sendMessageToUser({
                bot,
                userId: adminId,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª–∏–ª —á–∞—Ç —Å –±–æ—Ç–æ–º, —Å–æ–æ–±—â–µ–Ω—ñ–µ –µ–º—É –Ω–µ –±–∏–ª–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ',
              });
            }
          }
          if (status === Status.Reject || status === Status.ToEdit) {
            // const id = await getProductById({ id });
            await bot.sendMessage(
              adminId,
              `${id},${status}: –í—ã –∏–∑–º–∏–Ω–∏–ª–∏ —Å—Ç–∞—Ç—É—Å –Ω–∞ ${status}, –¥–ª—è –ø–æ—Å—ã–ª–∫–∏ ${id}  `,
              {},
            );
          } else {
            await bot.sendMessage(adminId, `–ü—Ä–æ–¥—É–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ç–∞—Ç—É—Å: ${status}`, {});
          }
        };

        switch (action) {
          case Status.OnReview:
            changeProductStatus({ id: productId, status: action, message: '–ó–∞–∫–∞–∑ –≤ —Ä–∞–±–æ—Ç–µ: ' });
            break;
          case Status.ToEdit:
            changeProductStatus({
              id: productId,
              status: action,
              message: '–ó–∞–∫–∞–∑ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å: ',
            });
            break;
          case Status.Reject:
            changeProductStatus({
              id: productId,
              status: action,
              message: '–ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω–µ–Ω: ',
            });
            break;
          case Status.Archive:
            changeProductStatus({
              id: productId,
              status: action,
              message: '–ó–∞–∫–∞–∑ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∞—Ä—Ö–∏–≤: ',
            });
            break;
          default:
            console.log('default');
        }
      } catch (err) {
        console.log('callback_query error');
      }
    });
  } catch (e) {
    console.log('admin controller error');
  }
};
